import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { randomBytes } from 'crypto';

const ROOT_DIR = process.cwd();

/**
 * Validate Anthropic API key by making a minimal test call
 */
export async function validateAnthropicKey(key) {
  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': key,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'Hi' }],
      }),
    });

    if (response.status === 401) {
      return { valid: false, error: 'Invalid API key' };
    }
    if (response.status === 400) {
      // Bad request but key is valid (e.g., rate limit, model error)
      return { valid: true };
    }
    if (response.ok) {
      return { valid: true };
    }
    return { valid: false, error: `HTTP ${response.status}` };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

/**
 * Build flat secrets JSON for SECRETS GitHub secret.
 * Takes a flat { ENV_VAR: value } map of collected keys.
 * entrypoint.sh decodes and exports each as an env var.
 */
export function buildSecretsJson(pat, collectedKeys) {
  return { GH_TOKEN: pat, ...collectedKeys };
}

/**
 * Encode secrets to base64 for SECRETS GitHub secret
 */
export function encodeSecretsBase64(pat, collectedKeys) {
  const secrets = buildSecretsJson(pat, collectedKeys);
  return Buffer.from(JSON.stringify(secrets)).toString('base64');
}

/**
 * Build LLM secrets JSON for LLM_SECRETS GitHub secret.
 * These credentials are accessible to the LLM (not filtered by env-sanitizer).
 */
export function buildLlmSecretsJson(llmKeys) {
  return { ...llmKeys };
}

/**
 * Encode LLM secrets to base64 for LLM_SECRETS GitHub secret.
 * Returns null if no LLM secrets are configured.
 */
export function encodeLlmSecretsBase64(llmKeys) {
  const secrets = buildLlmSecretsJson(llmKeys);
  if (Object.keys(secrets).length === 0) return null;
  return Buffer.from(JSON.stringify(secrets)).toString('base64');
}

/**
 * Generate .pi/agent/models.json for providers not built into PI.
 * PI resolves the apiKey field as an env var name at runtime ($ENV_VAR).
 */
export function writeModelsJson(providerName, { baseUrl, apiKey, api, models }) {
  const config = {
    providers: {
      [providerName]: {
        baseUrl,
        apiKey,
        api: api || 'openai-completions',
        models: models.map((m) => ({ id: m })),
      },
    },
  };
  const dir = join(ROOT_DIR, '.pi', 'agent');
  mkdirSync(dir, { recursive: true });
  writeFileSync(join(dir, 'models.json'), JSON.stringify(config, null, 2));
}

/**
 * Write .env file at project root
 */
export function writeEnvFile(config) {
  const {
    githubToken,
    githubOwner,
    githubRepo,
    telegramBotToken,
    telegramWebhookSecret,
    ghWebhookSecret,
    llmProvider,
    llmModel,
    providerEnvKey,
    providerApiKey,
    openaiApiKey,
    telegramChatId,
    telegramVerification,
  } = config;

  // Build the provider API key line(s)
  // Always write the provider's key; also write OPENAI_API_KEY if it's a separate key (for Whisper)
  let apiKeyLines = `# LLM API key (${providerEnvKey})\n${providerEnvKey}=${providerApiKey}`;
  if (providerEnvKey !== 'OPENAI_API_KEY') {
    apiKeyLines += `\n\n# OpenAI API key for Whisper voice transcription (optional)\nOPENAI_API_KEY=${openaiApiKey || ''}`;
  }

  // Generate AUTH_SECRET (32 random bytes, base64 encoded)
  const authSecret = randomBytes(32).toString('base64');

  const envContent = `# thepopebot Configuration
# Generated by setup wizard

# Auth.js secret (used for session encryption)
AUTH_SECRET=${authSecret}

# GitHub Personal Access Token (fine-grained: Actions, Contents, Metadata, Pull requests)
GH_TOKEN=${githubToken}

# Repository info
GH_OWNER=${githubOwner}
GH_REPO=${githubRepo}

# LLM provider and model (used by both Event Handler and Docker Agent)
LLM_PROVIDER=${llmProvider}
LLM_MODEL=${llmModel}

# Telegram bot token from @BotFather
TELEGRAM_BOT_TOKEN=${telegramBotToken || ''}

# Telegram webhook secret (validates requests are from Telegram)
TELEGRAM_WEBHOOK_SECRET=${telegramWebhookSecret || ''}

# Telegram chat ID (restricts bot to this chat only)
TELEGRAM_CHAT_ID=${telegramChatId || ''}

# Telegram verification code (used during setup, can be removed after)
TELEGRAM_VERIFICATION=${telegramVerification || ''}

# Secret for GitHub Actions webhook auth (must match GH_WEBHOOK_SECRET secret)
GH_WEBHOOK_SECRET=${ghWebhookSecret}

${apiKeyLines}
`;

  const envPath = join(ROOT_DIR, '.env');
  writeFileSync(envPath, envContent);
  return envPath;
}

/**
 * Update a single variable in an existing .env file
 */
export function updateEnvVariable(key, value) {
  const envPath = join(ROOT_DIR, '.env');
  if (!existsSync(envPath)) {
    throw new Error('.env file not found. Run npm run setup first.');
  }

  let content = readFileSync(envPath, 'utf-8');
  const regex = new RegExp(`^${key}=.*$`, 'm');

  if (regex.test(content)) {
    content = content.replace(regex, `${key}=${value}`);
  } else {
    content = content.trimEnd() + `\n${key}=${value}\n`;
  }

  writeFileSync(envPath, content);
  return envPath;
}
